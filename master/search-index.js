var N=null,E="",T="t",U="u",searchIndex={};
var R=["random","try_new","result","usize","borrow","borrow_mut","refmut","Creates a new [`SecretVec`] with `len` elements, filled…","Returns the size in bytes of `Self`.","as_u8_ptr","Returns a `*const u8` pointer to the beginning of the data.","as_mut_u8_ptr","Returns a `*mut u8` pointer to the beginning of the data.","Types that can be safely initialized by setting their…","try_from","try_into","to_owned","clone_into","type_id","formatter","uninitialized","secrets::traits","Returns an uninitialized value.","as_bytes","Returns a byte slice to the underlying data.","as_mut_bytes","Returns a mutable byte slice to the underlying data.","constant_eq","Compares `self` and `rhs`. Guaranteed to return false when…","randomize","Randomizes the contents of `self`.","Zeroes out the underlying storage.","transfer","Copies all bytes from `self` into `other` before zeroing…","SecretBox","SecretVec","AsContiguousBytes","ConstantEq","Randomizable","Zeroable"];
searchIndex["secrets"]={"doc":"Protected-access memory for cryptographic secrets.","i":[[3,"Secret","secrets","A type for protecting secrets allocated on the stack.",N,N],[3,R[34],E,"A type for protecting fixed-length secrets allocated on…",N,N],[3,R[35],E,"A type for protecting variable-length secrets allocated on…",N,N],[11,"new",E,"Creates a new [`Secret`] and invokes the provided callback…",0,[[["f"]],[U]]],[11,"zero",E,"Creates a new [`Secret`] filled with zeroed bytes and…",0,[[["f"]],[U]]],[11,"from",E,"Creates a new [`Secret`] from existing, unprotected data,…",0,[[["f"],[T]],[U]]],[11,R[0],E,"Creates a new [`Secret`] filled with random bytes and…",0,[[["f"]],[U]]],[11,"new",E,"Instantiates and returns a new [`SecretBox`].",1,[[["f"]],["self"]]],[11,R[1],E,"Instantiates and returns a new [`SecretBox`]. Has…",1,[[["f"]],[R[2]]]],[11,"size",E,"Returns the size in bytes of the [`SecretBox`].",1,[[["self"]],[R[3]]]],[11,R[4],E,"Immutably borrows the contents of the [`SecretBox`].…",1,[[["self"]],["ref"]]],[11,R[5],E,"Mutably borrows the contents of the [`SecretBox`]. Returns…",1,[[["self"]],[R[6]]]],[11,R[0],E,"Creates a new [`SecretBox`] filled with…",1,[[],["self"]]],[11,"zero",E,"Creates a new [`SecretBox`] filled with zeroes.",1,[[],["self"]]],[11,"new",E,"Instantiates and returns a new `SecretVec`.",2,[[[R[3]],["f"]],["self"]]],[11,R[1],E,"Instantiates and returns a new [`SecretVec`]. Has…",2,[[["f"]],[R[2]]]],[11,"len",E,"Returns the number of elements in the [`SecretVec`].",2,[[["self"]],[R[3]]]],[11,"is_empty",E,"Returns true if length of the [`SecretVec`] is zero.",2,[[["self"]],["bool"]]],[11,"size",E,"Returns the size in bytes of the [`SecretVec`].",2,[[["self"]],[R[3]]]],[11,R[4],E,"Immutably borrows the contents of the [`SecretVec`].…",2,[[["self"]],["ref"]]],[11,R[5],E,"Mutably borrows the contents of the [`SecretVec`]. Returns…",2,[[["self"]],[R[6]]]],[11,R[0],E,R[7],2,[[[R[3]]],["self"]]],[11,"zero",E,R[7],2,[[[R[3]]],["self"]]],[0,"traits",E,"Marker traits to allow types to be contained as secrets.",N,N],[8,R[36],R[21],"Marker trait for types who are intrepretable as a series…",N,N],[10,"size",E,R[8],3,[[["self"]],[R[3]]]],[10,R[9],E,R[10],3,[[["self"]]]],[10,R[11],E,R[12],3,[[["self"]]]],[11,R[23],E,R[24],3,[[["self"]]]],[11,R[25],E,R[26],3,[[["self"]]]],[8,"Bytes",E,"A marker trait for types whose size is known at compile…",N,N],[11,R[20],E,R[22],4,[[],["self"]]],[11,"size",E,R[8],4,[[],[R[3]]]],[11,R[9],E,R[10],4,[[["self"]]]],[11,R[11],E,R[12],4,[[["self"]]]],[8,R[37],E,"A marker trait for types that can be compared for equality…",N,N],[11,R[27],E,R[28],5,[[["self"]],["bool"]]],[8,R[38],E,R[13],N,N],[11,R[29],E,R[30],6,[[["self"]]]],[8,R[39],E,R[13],N,N],[11,"zero",E,R[31],7,[[["self"]]]],[11,R[32],E,R[33],7,[[["self"]]]],[11,"from","secrets",E,0,[[[T]],[T]]],[11,"into",E,E,0,[[],[U]]],[11,R[14],E,E,0,[[[U]],[R[2]]]],[11,R[15],E,E,0,[[],[R[2]]]],[11,R[4],E,E,0,[[["self"]],[T]]],[11,R[5],E,E,0,[[["self"]],[T]]],[11,R[18],E,E,0,[[["self"]],["typeid"]]],[11,R[16],E,E,1,[[["self"]],[T]]],[11,R[17],E,E,1,[[["self"],[T]]]],[11,"from",E,E,1,[[[T]],[T]]],[11,"into",E,E,1,[[],[U]]],[11,R[14],E,E,1,[[[U]],[R[2]]]],[11,R[15],E,E,1,[[],[R[2]]]],[11,R[4],E,E,1,[[["self"]],[T]]],[11,R[5],E,E,1,[[["self"]],[T]]],[11,R[18],E,E,1,[[["self"]],["typeid"]]],[11,R[16],E,E,2,[[["self"]],[T]]],[11,R[17],E,E,2,[[["self"],[T]]]],[11,"from",E,E,2,[[[T]],[T]]],[11,"into",E,E,2,[[],[U]]],[11,R[14],E,E,2,[[[U]],[R[2]]]],[11,R[15],E,E,2,[[],[R[2]]]],[11,R[4],E,E,2,[[["self"]],[T]]],[11,R[5],E,E,2,[[["self"]],[T]]],[11,R[18],E,E,2,[[["self"]],["typeid"]]],[11,"drop",E,"Ensures that the [`Secret`]'s underlying memory is…",0,[[["self"]]]],[11,"clone",E,E,1,[[["self"]],["secretbox"]]],[11,"clone",E,E,2,[[["self"]],["secretvec"]]],[11,"eq",E,E,1,[[["self"]],["bool"]]],[11,"eq",E,E,2,[[["self"]],["bool"]]],[11,"from",E,"Creates a new [`SecretBox`] from existing, unprotected…",1,[[[T]],["self"]]],[11,"from",E,"Creates a new [`SecretVec`] from existing, unprotected…",2,[[],["self"]]],[11,"fmt",E,E,1,[[["self"],[R[19]]],[R[2]]]],[11,"fmt",E,E,2,[[["self"],[R[19]]],[R[2]]]],[11,R[20],R[21],R[22],4,[[],["self"]]],[11,"size",E,R[8],4,[[],[R[3]]]],[11,R[9],E,R[10],4,[[["self"]]]],[11,R[11],E,R[12],4,[[["self"]]]],[11,R[23],E,R[24],3,[[["self"]]]],[11,R[25],E,R[26],3,[[["self"]]]],[11,R[27],E,R[28],5,[[["self"]],["bool"]]],[11,R[29],E,R[30],6,[[["self"]]]],[11,"zero",E,R[31],7,[[["self"]]]],[11,R[32],E,R[33],7,[[["self"]]]]],"p":[[3,"Secret"],[3,R[34]],[3,R[35]],[8,R[36]],[8,"Bytes"],[8,R[37]],[8,R[38]],[8,R[39]]]};
initSearch(searchIndex);addSearchOptions(searchIndex);